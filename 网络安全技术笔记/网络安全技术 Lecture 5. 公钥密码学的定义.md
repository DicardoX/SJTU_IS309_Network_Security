# 网络安全技术 Lecture 5. 公钥密码学的定义



## 1. Motivation

- **对称密钥分布管理 (Symmetric Key Distribution and Management)**的局限性：
  
  - 密钥数目过多
  
    ​		 <img src="./cut/截屏2021-03-16 下午1.44.00.png" alt="avatar z" style="zoom:60%;"/>
  
- **中心化密钥管理 (Centralized Key Management)**：每个用户只和管理机构共享一个长期密钥，**长期密钥仅用来在用户间安全传输会话密钥`session keys`**，**数据由会话密钥进行加密/解密**

  局限性：

  - 管理机构可信任度问题
  - 管理机构可能存在宕机风险 $\Rightarrow$ 无法进行会话密钥的指派
  - 效率不高<img src="./cut/截屏2021-03-16 下午1.48.43.png" alt="avatar siz" style="zoom:60%;" />

----



## 2. 公钥密码学的定义



|        | 私钥密码学 | 公钥密码学   |
| ------ | ---------- | ------------ |
| 机密性 | 私钥加密   | 公钥加密     |
| 完整性 | 消息验证码 | 数字签名策略 |

​	**内容**

- **公钥加密**：生成 (公钥, 私钥) 密钥对，使用公钥进行加密，使用私钥进行解密
- **数字签名**：生成 (公钥, 私钥) 密钥对，使用私钥基于明文生成签名，使用公钥基于铭文和签名来认证

-----



## 3. 公钥加密

### 3.1 流程

- 接收者Bob持有一个钥匙对：公钥 + 私钥
  - 公钥被发布，公开（公钥本`public key directory`）
  - 私钥为私密持有
- 其他人使用Bob的公钥来为Bob加密消息
  - 生成密文，只有对应的私钥才能正确解密
- Bob使用自己的私钥来解密

--------------

### 3.2 语法`Syntax`

- **密钥生成算法：$KeyGen(\lambda) \rightarrow (pk, sk)$**.
  - 输入：**安全参数$\lambda$**
  - 输出： (公钥, 私钥) 对$(pk, sk)$
- **加密算法：$Enc(pk, m) \rightarrow c$** .
  - 输入：**公钥$pk$**  + **明文`m`**（明文空间`M`可能取决于公钥$pk$）
  - 输出：**密文`c`**
- **解密算法：$Dec(sk, c) \rightarrow m$** .
  - 输入：**私钥$sk$**  + 密文`c`（此处省略了公钥$pk$）
  - 输出：**明文`m`**（或者一个特殊符号来表示错误） 
- **Correctness**
  - $Dec(sk, Enc(pk, m)) = m$ 

--------

### 3.3 安全性定义

- **安全性要求/安全保障**
  - 要求1：**无法从密文`c`获得私钥或明文`m`**
  - 要求2：**无法从公钥获得私钥**

- **威胁模型`Security Model`**

  - **CPA安全**（选择明文攻击安全）：

    - **考虑**如下公钥加密 $\Pi = (KeyGen, Enc, Dec)$ 的实验，假定一个攻击者 $A$，以及安全参数 $\lambda$
    - **准备阶段**：运行 $KeyGen(\lambda)$ 获得 (公钥, 密钥) 对 $(pk, sk)$ ，并将安全参数 $\lambda$ 和公钥 $pk$ 提供给攻击者 $A$
    - **挑战阶段**：攻击者 $A$ 输出一对长度相同的明文 $m_0^* \neq m_1^* \in M$ ，被攻击者选择一个特殊的比特 $b \in \{0, 1\}$ ，以此为依据选择使用哪一个明文，并计算 $c^* \leftarrow Enc(pk, m_b^*)$ ，将**挑战密文**$c^*$提供给攻击者 $A$ 
    - **输出阶段**：攻击者 $A$ 基于收到的挑战密文 $c^*$ 输出一个比特 $b' \in \{0, 1\}$ ，来猜测 $b$ 
    - 若 $b' = b$ ，则攻击者 $A$ 成功。将**攻击者 $A$ 的优势** 定义为$Adv_{\Pi, A}^{CPA} = |Pr[b'=b] - 1/2|$ ，则我们定义一个**公钥加密策略 $\Pi = (KeyGen, Enc, Dec)$ 是CPA安全**的条件是：**对于所有PPT攻击者 $A$ ，都存在一个可忽略的函数 $negl$ 使得 $Adv_{\Pi, A}^{CPA} \leq negl(\lambda)$ **.

    

    - <font color=blue size=3>注意：</font>**CPA安全下的公钥加密没有学习阶段`Probing Phase`**，原因是攻击者能够获得公钥，进而获得任何明文的密文（自我学习），因此**加密算法必须为随机性算法**

  


  - **CCA安全**（选择密文攻击安全）：

    - **考虑**如下公钥加密 $\Pi = (KeyGen, Enc, Dec)$ 的实验，假定一个攻击者$A$，以及安全参数$\lambda$
    - **准备阶段**：运行 $KeyGen(\lambda)$ 获得 (公钥, 密钥) 对 $(pk, sk)$ ，并将安全参数 $\lambda$ 和公钥 $pk$ 提供给攻击者 $A$
    - **学习阶段一**：**给予攻击者 $A$ 对 $Dec_{sk}(·)$ 的oracle访问权限**，即当攻击者 $A$ 向 $Dec_{sk}(·)$ 提交一个密文 $c \in C$ ，相应解码后的明文 $m \leftarrow Dec(sk, c)$ 被返回
    - **挑战阶段**：攻击者 $A$ 输出一对长度相同的明文 $m_0^* \neq m_1^* \in M$ ，被攻击者选择一个特殊的比特 $b \in \{0, 1\}$ ，以此为依据选择使用哪一个明文，并计算 $c^* \leftarrow Enc(pk, m_b^*)$ ，将**挑战密文**$c^*$提供给攻击者 $A$ 
    - **学习阶段二**：与学习阶段一相同，但攻击者 $A$ 不被允许向 $Dec_{sk}(·)$ 询问挑战密文 $c^*$ 
    - **输出阶段**：攻击者 $A$ 基于收到的挑战密文 $c^*$ 输出一个比特 $b' \in \{0, 1\}$ ，来猜测 $b$ 
    - 若 $b' = b$ ，则攻击者 $A$ 成功。将**攻击者 $A$ 的优势** 定义为$Adv_{\Pi, A}^{CCA} = |Pr[b'=b] - 1/2|$ ，则我们定义一个**公钥加密策略 $\Pi = (KeyGen, Enc, Dec)$ 是CCA安全**的条件是：**对于所有PPT攻击者 $A$ ，都存在一个可忽略的函数 $negl$ 使得 $Adv_{\Pi, A}^{CCA} \leq negl(\lambda)$ **.

    

  - <font color=blue size=3>注意：</font>CCA安全的威胁模型除了两个学习阶段之外均与CPA安全威胁模型相同

------



## 4. 数字签名`Digital Signature`

### 4.1 流程

- 数字签名用来为公钥加密提供完整性

- 签名者使用个人的**私钥**来为一个消息`m`生成一个签名$\sigma$ （签名过程）

  给定明文`m`、签名$\sigma$和**公钥**，任何人可以认证该 (m, $\sigma$) 消息 - 签名对是否合法（验证过程）

----------------

### 4.2 语法`Syntax`

- **密钥生成算法：$KeyGen(\lambda) \rightarrow (pk, sk)$**.
  - 输入：**安全参数 $\lambda$**
  - 输出： (公钥, 私钥) 对 $(pk, sk)$
- **签名算法：$Sign(sk, m) \rightarrow \sigma$** .
  - 输入：**私钥 $sk$**  + **明文 `m`**（明文空间`M`可能取决于公钥 $pk$）
  - 输出：**签名 $\sigma$** 
- **认证算法：$Verify(pk, m, \sigma) \rightarrow 1 / 0$** .
  - 输入：**公钥 $pk$ **  + 明文 `m`  + 签名 $\sigma$
  - 输出：**一个比特 $b \in \{0, 1\}$ **，$b=1$ 代表合法，$b=0$ 代表不合法
- **Correctness**
  - $Verify(pk, m, Sign(sk, m)) = 1$ for every message $m \in M$  

-------------

### 4.3 安全性定义

- **安全性要求/安全保障**：

  - 仅给定公钥 $pk$ 而没有相应的私钥 $sk$，没有攻击者能够利用公钥生成合法的 (消息, 签名) 对

- **威胁模型`Security Model`**：

  - **EUF安全**（**适应性选择消息攻击安全** ）：

    - **考虑**如下签名策略 $\Pi = (KeyGen, Sign, Verify)$ 的实验，假定一个攻击者 $A$，以及安全参数 $\lambda$ 

    - **准备阶段**：运行 $KeyGen(\lambda)$ 获得 (公钥, 密钥) 对 $(pk, sk)$ ，并将安全参数 $\lambda$ 和公钥 $pk$ 提供给攻击者 $A$

    - **学习阶段**：**给予攻击者 $A$ 对 $Sign_{sk}(·)$ 的oracle访问权限**，即当攻击者 $A$ 向 $Sign_{sk}(·)$ 提交一个明文 $m \in M$ ，相应的签名 $\sigma \leftarrow Sign(sk, m)$ 被返回

    - **输出阶段**：攻击者 $A$ 输出一个明文 $m^* \in M$ 和相应的签名 $\sigma^*$

    - 令 $Q$ 表示攻击者 $A$ 在学习阶段向 $Sign_{sk}(·)$ 提交的明文集合，若：

      - $Verify(pk, m^*, \sigma^*)=1$
      - $m^* \notin Q$ 

      则攻击者 $A$ 成功。将**攻击者 $A$ 的优势**定义为$Adv_{\Pi, A}^{EUF} = Pr[A \  succeeds]$，则我们定义一个**签名策略 $\Pi = (KeyGen, Sign, Verify)$  在适应性选择消息攻击下本质上不可伪造**的条件是：**对于所有PPT攻击者 $A$ ，都存在一个可忽略的函数 $negl$ 使得 $Adv_{\Pi, A}^{EUF} \leq negl(\lambda)$ **.

  - 任何攻击者无论看多多少消息 - 签名对，都无法根据选择消息`m*`来自己生成对应的签名$\sigma*$，即消息来源不会被篡改，**没有攻击者能够以不可忽略的优势伪造有效的 (消息, 签名) 对**

------

### 4.4 数字签名 vs MAC（消息验证码）

- **二者均提供完整性**
- 数字签名简化了密钥分布和管理
- 数字签名独有的**特征**：
  - **公开可验证性**：若某一方验证了该明文的数字签名的合法性，其他接收到此签名的机构也会将其验证为合法
  - **可转移性**：由公开可验证性保证
  - **不可否认性**：若一个用户进行了数字签名，他不可否认该行为（假设他的公钥已被发布）



###  









