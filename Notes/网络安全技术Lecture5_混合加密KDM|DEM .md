# 网络安全技术 Lecture 6. 混合加密`KDM: DEM`

------

## 1 混合加密 *KDM* / *DEM*

### 1.1 对称加密 *(SKE, Symmetric Key Encryption)* 和公钥加密 *(PKE, Public Key Encryption)* 的对比

- 对比：

|                    对称加密 *SKE*                    |                   公钥加密 *PKE*                   |
| :--------------------------------------------------: | :------------------------------------------------: |
|              两个 *Party* 必须互相信任               |             两个 *Party* 不用互相信任              |
| 都共享相同的密钥，或者一方的密钥可以从另一方计算得到 |          两个分别独立的密钥：公钥 + 私钥           |
|           攻击方案：暴力枚举 *Brute-force*           | 攻击方案：解决数学问题（例如：分解、离散对数问题） |
|                         更快                         |          更慢（要比 *SKE* 慢100-1000倍）           |
|                    更小的密钥大小                    |                   更大的密钥大小                   |

------



### 1.2 混合加密

- **简介**： 

  - 对称加密策略 *Secret Key Encryption Scheme*：比公钥加密的效率要显著高、主要问题在于**密钥分配问题**
  - 公钥加密策略：*Public Key Encryption Scheme*：更慢、无密钥分配问题
  - **混合加密策略**：
    - **使用公钥加密来避免密钥分配问题**
    - **使用对称加密来进行批量加密以提高效率**
  - 混合加密的使用实例：*PGP*、*SSL*、*IPSec*、*S/MIME*

- **策略**：

  - **使用公钥加密来加密一个对称密钥**，**使用对称密钥来通过 *AES* 加密数据**

    - 注意：**这里的对称密钥更像是会话密钥，*Bob* 不会长期持有** 

    <img src="./cut/截屏2021-04-18 下午4.59.45.png" alt="avatar" style="zoom:30%;" />
  
    - 注意：**对称密钥 *K* 一般要比明文短很多**，因此，$AES_k$ 获得的速度优势不会因为需要对*K* 进行公钥加密而无效
    - ***Bob* 不能确定他是否在和 *Alice* 通话**
    - ***Alice* 可以确定她在和 *Bob* 通话**
      - 原因是她使用了 $PKEnc_{Bob}(K)$ 来对对称密钥进行加密，因此只有 *Bob* 可以解开得到对称密钥
    - ***AES***：高级加密标准 *Advanced Encryption Standard*，为最常见的对称加密算法，就是最简单的加密/解密模型。
    - 加密模型：其中 *Enc* 表示公钥加密策略，*Enc'* 表示对称加密策略 *AES* 

    <img src="./cut/截屏2021-04-18 下午5.10.42.png" alt="avatar" style="zoom:25%;" />
  
  - *Sender*：
    - 选择一个唯一的 *K* 值，作为对称密钥
    - 使用公钥加密来对 *K* 值进行加密
    - 基于对称密钥 *K* 使用对称加密对 *Sender Data* 进行加密
    - 将加密后的 *K* 和加密后的 *Sender Data* 进行传输
    
  - *Receiver*：
    
    - 使用私钥解密得到对称密钥 *K* 
    - 使用对称密钥 *K* 解密得到 *Sender Data*
    - 基于对称密钥 *K* 使用对称加密对 *Receiver Data* 进行加密
    - 将加密后的 *Receiver Data* 进行传输，注意**此时不需要再将对称密钥进行公钥加密后回传给 *Sender***

--------



## 2 密钥封装机制 *KEM, Key-Encapsulation Mechanism*：

- 在上述混合加密的加密过程中，发送者需要做许多工作。一个更直接的方法是**使用被称为密钥封装机制 (KEM) 的公钥原语来在 *"one shot"* 内完成包括选取 *K* 和公钥加密 *K* 的工作**。 **相应的对称加密策略**被称为**数据封装机制 (*DEM, Data-Encapsulation Mechanism*)**。

<img src="./cut/截屏2021-04-18 下午10.12.59.png" alt="avatar" style="zoom:30%;" />

### 2.1 语法 *Syntax*：

- *KEM* 是一个 *(Gen, Encaps, Decaps)* 的概率多项式时间 *PPT* 算法的多元组：
- $Gen(1^n) \rightarrow (pk, \ sk)$：
  - 输入：安全参数 $1^n$
  - 输出：**公钥 - 私钥**对
- $Encaps(pk) \rightarrow (c, \ K)$：
  - 输入：公钥 *pk*
  - 输出：**密文 *c* （加密好的对称密钥）**和**对称密钥 *K* **
- $Decaps(sk, c) \rightarrow K$：
  - 输入：**私钥 *sk*** 和**密文 *c***
  - 输出：**对称密钥 *K* **或代表失败的符号 $\perp$ 

注意：上面的 *Sender* 和 *Receiver* 都会分别从加密和解密算法中获得之后要使用的对称密钥 *K* 

- **正确性 *Correctness***：
  - 只需证明，对于 *Gen* 输出的公钥 - 私钥对，在足够小的错误可能性之外，若 $Encaps(pk)$ 输出 *(c, K)*，则 $Decaps(sk, c)$ 会输出 *K*

---------

### 2.2 安全模型：

- 安全模型一：*CPA* 安全

  - **考虑**如下 *KEM* $\Pi = (Gen, Encaps, Decaps)$ 的实验，假定一个攻击者 $A$，以及安全参数 $1^n$
  - **准备阶段**：运行 $Gen(1^n)$ 获得公钥 - 私钥对 $(pk, sk)$ ，并将安全参数 $1^n$ 和公钥 $pk$ 提供给攻击者 $A$
  - **挑战阶段**：被攻击者运行加密算法 $(c^*, \ k) \leftarrow Encaps(pk)$ 。随机选择一个唯一的 *bit* $b \in \{0, 1\}$ ，若 *b = 0*，则设置 *k' = k*；否则，随机生成一个 $k' \in \{0, 1\}^n$，将 *(c\*, k')* 提供给攻击者 *A* 
  - **输出阶段**：攻击者 $A$ 基于收到的挑战密文 $c^*$ 输出一个比特 $b' \in \{0, 1\}$ ，来猜测 $b$ 。若 $b' = b$ ，则攻击者 $A$ 成功。将**攻击者 $A$ 的优势** 定义为$Adv_{\Pi, A}^{CPA} = |Pr[b'=b] - 1/2|$ ，则我们定义一个**密钥封装机制 $\Pi = (Gen, Encaps, Decaps)$ 是CPA安全**的条件是：**对于所有PPT攻击者 $A$ ，都存在一个可忽略的函数 $negl$ 使得 $Adv_{\Pi, A}^{CPA} \leq negl(\lambda)$ **.

  问题：

  - 比较 *KEM* 和 *PKE* 模型的异同：构造 *CPA* 安全的 *PKE* 更难，还是构造 *CPA* 安全的 *KEM* 更难?
    - **构造 *CPA* 安全的 *KEM* 更难** 。原因是在挑战阶段中，有一定的概率需要自行再随机生成一个 *k'* 以提供给攻击者 *A* 
  - 从一个 *PKE* 方案可以直接得到一个 *KEM* 方案（**只需要在挑战阶段进行修改，将由攻击者提供两个消息改成由被攻击者提供 $(c^*, k)$ 对，再由攻击者猜这个 $c^*$ 加密的内容是不是 $k$**），为什么还要提出 *KEM* 的这个概念？
    - 因为专门构建得到的密钥封装机制 *KEM* 可以变得更加灵活高效，例如密文的长度可以更短。
  - 是不是一个**公钥加密方案**就可以实现一个**密钥封装机制**？
    - 是的，可以用任何一个公钥加密方案构建一个密钥封装机制，且可以保证相同的安全性。
    - **只需要在挑战阶段进行修改，将由攻击者提供两个消息改成由被攻击者提供 $(c^*, k)$ 对，再由攻击者猜这个 $c^*$ 加密的内容是不是 $k$**
  - 是不是一个**密钥封装机制**就可以实现一个**公钥加密方案**？
    - 是的，可以用任何一个密钥封装机制构建一个公钥加密方案，但**在一定条件下**可以保证相同的安全性。

- 安全模型二：*CCA* 安全

  - **考虑**如下 *KEM*  $\Pi = (Gen, Encaps, Decaps)$ 的实验，假定一个攻击者$A$，以及安全参数$1^n$
  - **准备阶段**：运行 $Gen(1^n)$ 获得公钥 - 私钥对 $(pk, sk)$ ，并将安全参数 $1^n$ 和公钥 $pk$ 提供给攻击者 $A$
  - **学习阶段一**：**给予攻击者 $A$ 对 $Decaps_{sk}(·)$ 的oracle访问权限**，即当攻击者 $A$ 向 $Decaps_{sk}(·)$ 提交一个密文 $c \in C$ ，相应解码后的对称密钥 $k \leftarrow Decaps(sk, c)$ 被返回
  - **挑战阶段**：被攻击者运行加密算法 $(c^*, \ k) \leftarrow Encaps(pk)$ 。随机选择一个唯一的 *bit* $b \in \{0, 1\}$ ，若 *b = 0*，则设置 *k' = k*；否则，随机生成一个 $k' \in \{0, 1\}^n$，将 *(c\*, k')* 提供给攻击者 *A* 
  - **学习阶段二**：与学习阶段一相同，但攻击者 $A$ 不被允许向 $Dec_{sk}(·)$ 询问挑战密文 $c^*$ 
  - **输出阶段**：攻击者 $A$ 基于收到的挑战密文 $c^*$ 输出一个比特 $b' \in \{0, 1\}$ ，来猜测 $b$ 。若 $b' = b$ ，则攻击者 $A$ 成功。将**攻击者 $A$ 的优势** 定义为$Adv_{\Pi, A}^{CCA} = |Pr[b'=b] - 1/2|$ ，则我们定义一个**密钥封装机制 $\Pi = (Gen, Encaps, Decaps)$ 是CCA安全**的条件是：**对于所有PPT攻击者 $A$ ，都存在一个可忽略的函数 $negl$ 使得 $Adv_{\Pi, A}^{CCA} \leq negl(\lambda)$ **.

------



## 3 *EI Gammal-like* KEM

### 3.1 语法 *Syntax* 

- *GenGroup* 算法：
  - 通用、多项式、群生成算法
  - 输入：安全参数$1^n$（ ***n* 指示输出的长度为 *n-bit*** ），参数 *l(n)*
  - 输出：**循环群 *G* 的描述**，**序** *q* ($||q||=n$)，以及**生成元** $g \in G$ 
    - **循环群的描述**指示有多少个群里的元素被表示为比特串（假设每个群元素都被表示成一个独特的比特串）
    - 需要一个有效算法来计算群内的操作，以及验证一个比特串是否为群 *G* 内的元素
      - $h := g^x$：若 *x* 很大（如 *q - 1*），如何计算 *h* ？计算逆元（先模 *q*，再求逆元）
- $KeyGen(1^\lambda) \rightarrow (pk, sk)$：
  - 输入安全参数 $1^\lambda$，算法运行群生成算法 $GenGroup(1^\lambda)$ 来获得 *(G, q, g)*，然后随机选择一个 $x \in Z_q$ 并计算 $h := g^x$。然后为某个函数 *l* 指定一个函数 $H: G \rightarrow \{0, 1\}^{l(\lambda)}$ ，公钥为 $pk := (G, q, g, h, H)$，私钥为 $sk := (G, q, g, x)$
- $Encaps(pk) \rightarrow (c, k)$：
  - 输入公钥 $pk = (G, q, g, h, H)$，算法随机选择一个 $y \in Z_q$，输出密文 $(c := g^y, k := H(h^y))$
- $Decaps(sk, \ c) \rightarrow k$：
  - 输入私钥 $sk = (G, q, g, x)$ 和密文 $c \in G$，输出对称密钥 $k = H(c^x)$

- 注意：**函数 *H* 的作用是将群空间中的元素映射为 *0-1* 串，进而生成对称密钥 *k***
  - **函数的 *H* 的选择**：选择一个函数 $H: G \rightarrow \{0, 1\}^{l(\lambda)}$ 满足，**对任何可能的 $k \in \{0, 1\}^{\lambda}$，映射到对称密钥 *k* 的群元素数目是近似相同的。**
    - 这保证了对称密钥 *k* 的分布在统计意义上是接近均匀的
    - *H* 的复杂度和密钥长度 *l* 都依赖于使用的群 *G* 
- **正确性 *Correctness***：
  - $h^y = (g^x)^y = g^{xy} = c^x$，再套上函数 *H* 即可

-------

### 3.2 安全性证明

- 定理一：若**基于群生成算法 *GenGroup()* 定义的 *DDH* 问题是困难的**，且***H* 按照上述原则进行选取**，则上述 *EI Gammal-like KEM* 是 ***CPA*** 安全的 
- 定理二：若**基于群生成算法 *GenGroup()* 定义的 *CDH* 问题是困难的**，且***H*被建模为随机 *oracle***，则上述 *EI Gammal-like KEM* 是 ***CPA*** 安全的 

-----



## 4 基于 *KEM/DEM* 的混合加密

- 令 $\Pi = (Gen, Encaps, Decaps)$ 为**对称密钥长度为 *n* 的 *KEM***，令 $\Pi' = (Gen', Enc', Dec')$ 为相应的**对称加密策略**，如下构造一个**公钥加密策略** $\Pi^{hy} = (Gen^{hy}, Enc^{hy}, Dec^{hy})$：

  -  $Gen^{hy}(1^n)$：
    - 输入安全参数 $1^n$，运行 ***KEM* 中的密钥生成算法 $Gen(1^n)$** 来生成公钥 - 私钥对 *(pk, sk)*
  - $Enc^{hy}(pk, m)$：
    - 输入公钥 *pk* 和消息 $m \in \{0, 1\}^*$，然后：
      - 使用 *KEM* 中的加密算法 $Encaps(pk)$ 来计算 *(c, k)*
      - 使用对称加密策略中的加密算法 $Enc'(k, m)$ 来计算 *c'*
      - 输出密文 *(c, c')*
  - $Dec^{hy}(sk, (c, c'))$：
    - 计算对称密钥 $k \leftarrow Decaps(sk, c)$
    - 输出消息 $m := Dec'(k, c')$

- **安全性证明**：

  - 定理：若 ***KEM* $\Pi$ 是 *CPA* 安全**，且**对称加密策略 $\Pi'$ 在有窃听者的情况下具有难以区分的加密**，则 **$\Pi^{hy}$ 是一个 *CPA* 安全的公钥加密策略**。

  注意：**“在有窃听者的情况下具有难以区分的加密”**指的是**唯密文攻击 *COA, Ciphertext Only Attack***

  - 定理：若 ***KEM* $\Pi$ 是 *CCA* 安全**，且**对称加密策略 $\Pi'$ 也是 *CCA* 安全**，则 **$\Pi^{hy}$ 是一个 *CCA* 安全的公钥加密策略**。

- 基于 *KEM/DEM* 的混合加密的效率：

  - 对于一些定值 *n*，令 $\alpha$ 表示使用 $Encaps$ 封装一个 *n-bit* 长度的密钥的花费，令 $\beta$ 表示使用 $Enc'$ 加密明文的花费，假设 $|m| > n$，则针对 $m$  长度的明文进行混合加密 $\Pi^{hy}$ 的每 *bit* 的花费为:
  
    ​																			$\frac{\alpha + \beta · |m|}{|m|} = \frac{\alpha}{|m|} + \beta$
  
  - 在足够长的明文条件下，$\Pi^{hy}$ 每 *bit* 的花费和对称加密策略 $\Pi'$ 的相同，原因是 *k* 的封装 *cost* 可以忽略不计。

 















